generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tenant {
  id         String   @id @default(cuid())
  name       String
  createdAt  DateTime @default(now())
  projects   Project[]
  users      User[]
}

model User {
  id         String   @id @default(cuid())
  tenantId   String
  email      String   @unique
  passhash   String
  role       String
  createdAt  DateTime @default(now())
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
}

model Project {
  id         String   @id @default(cuid())
  tenantId   String
  name       String
  timezone   String   @default("Europe/Berlin")
  createdAt  DateTime @default(now())
  tenant     Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  jobs       Job[]
}

enum JobType {
  http
  queue
  internal
}

model Job {
  id               String   @id @default(cuid())
  projectId        String
  name             String
  type             JobType
  scheduleCron     String?
  scheduleHuman    String?
  tz               String   @default("Europe/Berlin")
  // HTTP
  targetUrl        String?
  targetMethod     String?
  headersJson      Json?
  bodyTemplate     Json?
  // Queue
  queueName        String?
  messageTemplate  Json?
  // Internal
  internalHandler  String?
  handlerArgsJson  Json?

  retryMax         Int      @default(3)
  timeoutMs        Int      @default(15000)
  concurrency      Int      @default(1)
  paused           Boolean  @default(false)

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  project          Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  nextfires        JobNextFire[]
  runs             Run[]
}

model JobNextFire {
  jobId   String
  nextAt  DateTime
  version Int      @default(0)

  job     Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@id([jobId, nextAt])
  @@index([nextAt])
}

enum RunStatus {
  success
  failed
  running
}

model Run {
  id          String   @id @default(cuid())
  jobId       String
  projectId   String
  triggerAt   DateTime
  status      RunStatus
  attempts    Int      @default(0)
  durationMs  Int?
  firstError  String?
  createdAt   DateTime @default(now())

  job         Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)
  attemptsRel Attempt[]

  @@index([jobId, createdAt])
}

enum AttemptStatus {
  success
  failed
  timeout
}

model Attempt {
  id               String   @id @default(cuid())
  runId            String
  attemptNo        Int
  startedAt        DateTime
  finishedAt       DateTime?
  status           AttemptStatus
  httpStatus       Int?
  latencyMs        Int?
  errorMsg         String?
  responseExcerpt  String?
  idempotencyKey   String?

  run              Run      @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([status])
}